# Интерпретатор RISC-процессора для курса ИТМО &laquo;разработка компиляторов&raquo;

В одной строке записывается одна команда, псевдокоманда или метка.
Комментарии начинаются с \# и продолжаются до конца строки.

# Описание машины
- 2<sup>16</sup> (65536) ячеек памяти по 32 бита:
  - адрес первой ячейки &mdash; 0;
  - адрес последней ячейки &mdash; 65535;
- одна команда записывается в одну ячейку;
- счётчик команд &mdash; регистр, в который записывается адрес следующей команды, которая будет выполнена. На момент выполнения команды счётчик команд указывает на следующую команду;
- флаг останова &mdash; если установлен, автоматическое выполнение программы остановится;
- 32 адресуемых регистра x0&ndash;x31:
  - x0 всегда содержит 0;
  - x1&ndash;x31 &mdash; 32&ndash;битные регистры общего назначения;

# Команды
## Обозначения

- rd &mdash; регистр назначения;
- rs1 &mdash; первый регистр, из которого берется значение;
- rs2 &mdash; второй регистр, из которого берется значение;
- imm[n] &mdash; знаковая n-битная числовая константа;
- pc &mdash; счётчик команд на момент после выборки команды, т.е. указывает на следующую команду после выполняемой;
- := &mdash; присваивание;
- [d] &mdash; ячейка памяти по адресу d;
- << &mdash; битовый сдвиг влево, освободившиеся биты заполняются нулями;
- \>\> &mdash; арифметический битовый сдвиг вправо, освободившиеся биты заполняются старшим битом исходного значения;
- \>\>\> &mdash; логический битовый сдвиг влево, освободившиеся биты заполняются нулями;
- XOR &mdash; побитовое логическое исключающее ИЛИ;
- OR &mdash; побитовое логическое ИЛИ;
- AND &mdash; побитовое логическое И;
- % &mdash; остаток от деления;

## Команды виртуальной машины
| Команда | Пояснение |
| ------- | --------- |
| `lui rd, imm[20]` | rd := imm << 12 |
| `addi rd, rs1, imm[12]` | rd := rs1 + imm |
| `xori rd, rs1, imm[12]` | rd := rs1 XOR imm |
| `add rd, rs1, rs2` | rd := rs1 + rs2 |
| `sub rd, rs1, rs2` | rd := rs1 - rs2 |
| `xor rd, rs1, rs2` | rd := rs1 XOR rs2 |
| `srl rd, rs1, rs2` | rd := rs1 \>\>\> rs2 |
| `sra rd, rs1, rs2` | rd := rs1 \>\> rs2 |
| `or  rd, rs1, rs2` | rd := rs1 OR rs2 |
| `and rd, rs1, rs2` | rd := rs1 AND rs2 |
| `mul rd, rs1, rs2` | rd := rs1 \* rs2 |
| `div rd, rs1, rs2` | rd := rs1 / rs2 |
| `rem rd, rs1, rs2` | rd := rs1 % rs2 |
| `sll rd, rs1, rs2` | rd := rs1 &lt;&lt; rs2 |
| `slt rd, rs1, rs2` | если rs1 &lt; rs2, то rd := 1, иначе rd := 0 |
| `seq rd, rs1, rs2` | если rs1 = rs2, то rd := 1, иначе rd := 0 |
| `sne rd, rs1, rs2` | если rs1 &ne; rs2, то rd := 1, иначе rd := 0 |
| `sge rd, rs1, rs2` | если rs1 &geq; rs2, то rd := 1, иначе rd := 0 |
| `lw rd, rs1, imm[12]` | rd := [rs1 + imm] |
| `sw rs1, imm[12], rs2` | [rs1 + imm] := rs2 |
| `jalr rd, rs1, imm[12]` | rd := pc; pc := rs1 + imm |
| `jal rd, imm[20]` | rd := pc; pc := pc + imm |
| `beq rs1, rs2, imm[12]` | если rs1 = rs2, то pc := pc + imm |
| `bne rs1, rs2, imm[12]` | если rs1 &ne; rs2, то pc := pc + imm |
| `blt rs1, rs2, imm[12]` | если rs1 < rs2, то pc := pc + imm |
| `bge rs1, rs2, imm[12]` | если rs1 &geq; rs2, то pc := pc + imm |
| `ebreak` | установить флаг останова |
| `eread rd` | прочитать символ Unicode из поля ввода в rd |
| `ewrite rs1` | вывести символ Unicode из rs1 в поле вывода |

## Псевдокоманды
- `LABEL:` &mdash; установить метку `LABEL`.
  Метка соответствует адресу следующей команды;
- `data imm[32] * t` &mdash; t раз повторить imm;
- `li rd, imm[32]` &mdash; rd := imm &mdash; последовательность из `lui` и `addi`, после которой в rd будет значение imm;
- `li rd, LABEL` &mdash; rd := адрес метки `LABEL`. Всегда раскрывается строго в 2 команды;
- `jal rd, LABEL` &mdash; такой `jal`, который соответствует метке `LABEL`;
- `beq/bne/blt/bge rs1, rs2, LABEL` &mdash; условный переход на метку `LABEL`. Может не существовать, поскольку условный переход допускает смещение только до 12 бит. Для более длинных условных переходов можно использовать комбинацию из перехода по противоположному условию (beq &mdash; bne, blt &mdash; bge) на 1 (т.е. перепрыгнуть следующую команду) и прыжка `jal` на метку `LABEL`, например:
  ```
  # blt x1, x2, LABEL
  bge x1, x2, 1
  jal x0, LABEL
  # продолжение кода
  ```
